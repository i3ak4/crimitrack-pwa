<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Force Sanitize - CrimiTrack PWA</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            max-width: 900px;
            margin: 50px auto;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
        }
        .container {
            background: white;
            padding: 40px;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
        }
        h1 {
            color: #2c3e50;
            text-align: center;
            font-size: 2.5em;
            margin-bottom: 30px;
        }
        .status {
            padding: 20px;
            margin: 20px 0;
            border-radius: 10px;
            font-size: 1.1em;
        }
        .status.success {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }
        .status.error {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }
        .status.warning {
            background: #fff3cd;
            color: #856404;
            border: 1px solid #ffeeba;
        }
        button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 15px 40px;
            border-radius: 50px;
            font-size: 1.2em;
            cursor: pointer;
            display: block;
            margin: 30px auto;
            transition: transform 0.3s;
        }
        button:hover {
            transform: scale(1.05);
        }
        .results {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 10px;
            margin-top: 20px;
        }
        .before-after {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin: 20px 0;
        }
        .column {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 10px;
        }
        .column h3 {
            color: #495057;
            margin-top: 0;
        }
        pre {
            background: white;
            padding: 10px;
            border-radius: 5px;
            overflow-x: auto;
            font-size: 12px;
            max-height: 400px;
            overflow-y: auto;
        }
        .problem {
            background: #ffcccc;
            font-weight: bold;
        }
        .fixed {
            background: #ccffcc;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üßπ Force Sanitization - CrimiTrack PWA</h1>
        
        <div id="initial-status" class="status warning">
            Pr√™t √† nettoyer les donn√©es...
        </div>
        
        <button onclick="forceSanitize()">
            üöÄ Forcer le Nettoyage Complet
        </button>
        
        <div class="before-after" id="comparison" style="display: none;">
            <div class="column">
                <h3>‚ùå Avant (avec probl√®mes)</h3>
                <pre id="before-data"></pre>
            </div>
            <div class="column">
                <h3>‚úÖ Apr√®s (nettoy√©)</h3>
                <pre id="after-data"></pre>
            </div>
        </div>
        
        <div id="results" class="results" style="display: none;">
            <h3>üìä R√©sultats du nettoyage</h3>
            <div id="results-content"></div>
        </div>
    </div>
    
    <script>
        async function forceSanitize() {
            const statusDiv = document.getElementById('initial-status');
            statusDiv.className = 'status warning';
            statusDiv.textContent = '‚è≥ Nettoyage en cours...';
            
            // 1. Charger les donn√©es depuis localStorage
            const localData = localStorage.getItem('crimitrack-database');
            if (!localData) {
                statusDiv.className = 'status error';
                statusDiv.textContent = '‚ùå Aucune donn√©e trouv√©e dans localStorage';
                return;
            }
            
            let database;
            try {
                database = JSON.parse(localData);
            } catch (e) {
                statusDiv.className = 'status error';
                statusDiv.textContent = '‚ùå Erreur lors du parsing des donn√©es';
                return;
            }
            
            // Afficher les donn√©es avant
            const beforeData = JSON.stringify(database.expertises[0], null, 2);
            document.getElementById('before-data').textContent = beforeData;
            
            // 2. Statistiques avant nettoyage
            let problemCount = 0;
            const problemFields = new Set();
            
            database.expertises.forEach(expertise => {
                Object.entries(expertise).forEach(([key, value]) => {
                    if (key.startsWith('_')) return; // Ignorer les champs syst√®me
                    
                    if (value === undefined || 
                        value === 'undefined' || 
                        value === null || 
                        value === 'null' ||
                        value === 'UNDEFINED' ||
                        value === 'Undefined' ||
                        String(value).toLowerCase() === 'undefined' ||
                        String(value).toLowerCase() === 'null') {
                        problemCount++;
                        problemFields.add(key);
                    }
                });
            });
            
            console.log(`üîç Probl√®mes d√©tect√©s: ${problemCount} valeurs dans ${problemFields.size} champs`);
            
            // 3. Nettoyer les donn√©es
            const cleanedDatabase = {
                expertises: database.expertises.map(expertise => {
                    const cleaned = {};
                    
                    Object.entries(expertise).forEach(([key, value]) => {
                        // Pr√©server les champs syst√®me
                        if (key.startsWith('_')) {
                            cleaned[key] = value;
                            return;
                        }
                        
                        // Nettoyer les valeurs probl√©matiques
                        if (value === undefined || 
                            value === 'undefined' || 
                            value === null || 
                            value === 'null' ||
                            value === 'UNDEFINED' ||
                            value === 'Undefined' ||
                            String(value).toLowerCase() === 'undefined' ||
                            String(value).toLowerCase() === 'null' ||
                            String(value).trim() === '') {
                            cleaned[key] = '';
                            console.log(`‚ú® Nettoy√©: ${key} √©tait "${value}", maintenant ""`);
                        } else {
                            // Nettoyer les cha√Ænes qui contiennent "undefined"
                            let cleanValue = String(value);
                            if (cleanValue.includes('undefined')) {
                                cleanValue = cleanValue.replace(/undefined/gi, '').trim();
                                console.log(`‚ú® Nettoy√©: ${key} contenait "undefined", maintenant "${cleanValue}"`);
                            }
                            cleaned[key] = cleanValue;
                        }
                    });
                    
                    return cleaned;
                })
            };
            
            // Afficher les donn√©es apr√®s
            const afterData = JSON.stringify(cleanedDatabase.expertises[0], null, 2);
            document.getElementById('after-data').textContent = afterData;
            document.getElementById('comparison').style.display = 'block';
            
            // 4. Statistiques apr√®s nettoyage
            let remainingProblems = 0;
            cleanedDatabase.expertises.forEach(expertise => {
                Object.entries(expertise).forEach(([key, value]) => {
                    if (key.startsWith('_')) return;
                    
                    if (String(value).toLowerCase().includes('undefined') ||
                        String(value).toLowerCase().includes('null')) {
                        remainingProblems++;
                        console.error(`‚ö†Ô∏è Probl√®me restant: ${key} = "${value}"`);
                    }
                });
            });
            
            // 5. Sauvegarder les donn√©es nettoy√©es
            localStorage.setItem('crimitrack-database', JSON.stringify(cleanedDatabase));
            
            // 6. Sauvegarder aussi dans IndexedDB
            await saveToIndexedDB(cleanedDatabase);
            
            // 7. Afficher les r√©sultats
            const resultsContent = document.getElementById('results-content');
            resultsContent.innerHTML = `
                <p>üìä <strong>Expertises trait√©es:</strong> ${cleanedDatabase.expertises.length}</p>
                <p>üêõ <strong>Probl√®mes trouv√©s:</strong> ${problemCount}</p>
                <p>‚ú® <strong>Probl√®mes corrig√©s:</strong> ${problemCount - remainingProblems}</p>
                <p>‚ö†Ô∏è <strong>Probl√®mes restants:</strong> ${remainingProblems}</p>
                <p>üìù <strong>Champs affect√©s:</strong> ${Array.from(problemFields).join(', ')}</p>
            `;
            document.getElementById('results').style.display = 'block';
            
            if (remainingProblems === 0) {
                statusDiv.className = 'status success';
                statusDiv.textContent = '‚úÖ Toutes les donn√©es ont √©t√© nettoy√©es avec succ√®s!';
            } else {
                statusDiv.className = 'status warning';
                statusDiv.textContent = `‚ö†Ô∏è Nettoyage termin√© mais ${remainingProblems} probl√®me(s) subsiste(nt)`;
            }
        }
        
        async function saveToIndexedDB(database) {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open('CrimiTrackDB', 1);
                
                request.onupgradeneeded = (event) => {
                    const db = event.target.result;
                    if (!db.objectStoreNames.contains('database')) {
                        db.createObjectStore('database');
                    }
                };
                
                request.onsuccess = (event) => {
                    const db = event.target.result;
                    const transaction = db.transaction(['database'], 'readwrite');
                    const store = transaction.objectStore('database');
                    
                    const putRequest = store.put({
                        data: database,
                        timestamp: new Date().toISOString()
                    }, 'main');
                    
                    putRequest.onsuccess = () => {
                        console.log('‚úÖ Donn√©es nettoy√©es sauvegard√©es dans IndexedDB');
                        resolve();
                    };
                    
                    putRequest.onerror = () => {
                        console.error('‚ùå Erreur sauvegarde IndexedDB');
                        reject();
                    };
                };
                
                request.onerror = () => {
                    console.error('‚ùå Erreur ouverture IndexedDB');
                    reject();
                };
            });
        }
        
        // V√©rifier l'√©tat initial
        window.addEventListener('load', () => {
            const localData = localStorage.getItem('crimitrack-database');
            if (localData) {
                try {
                    const database = JSON.parse(localData);
                    let problemCount = 0;
                    
                    database.expertises.forEach(expertise => {
                        Object.entries(expertise).forEach(([key, value]) => {
                            if (key.startsWith('_')) return;
                            
                            if (value === undefined || 
                                value === 'undefined' || 
                                value === null || 
                                value === 'null' ||
                                String(value).toLowerCase() === 'undefined') {
                                problemCount++;
                            }
                        });
                    });
                    
                    if (problemCount > 0) {
                        document.getElementById('initial-status').textContent = 
                            `‚ö†Ô∏è ${problemCount} valeur(s) probl√©matique(s) d√©tect√©e(s). Cliquez pour nettoyer.`;
                    } else {
                        document.getElementById('initial-status').className = 'status success';
                        document.getElementById('initial-status').textContent = 
                            '‚úÖ Les donn√©es sont d√©j√† propres!';
                    }
                } catch (e) {
                    console.error('Erreur parsing:', e);
                }
            } else {
                document.getElementById('initial-status').className = 'status error';
                document.getElementById('initial-status').textContent = 
                    '‚ùå Aucune donn√©e trouv√©e';
            }
        });
    </script>
</body>
</html>