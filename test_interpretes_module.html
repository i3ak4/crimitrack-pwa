<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Test Module Interprètes - CrimiTrack PWA</title>
    <link rel="stylesheet" href="styles.css">
    <style>
        .test-results {
            position: fixed;
            top: 10px;
            right: 10px;
            background: white;
            padding: 1rem;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
            z-index: 1000;
            max-width: 300px;
            font-size: 0.875rem;
        }
        
        .test-success {
            color: #27ae60;
            font-weight: 600;
        }
        
        .test-error {
            color: #e74c3c;
            font-weight: 600;
        }
        
        .test-info {
            color: #3498db;
            margin-bottom: 0.5rem;
        }
        
        .device-info {
            background: #f8f9fa;
            padding: 0.5rem;
            border-radius: 4px;
            margin-bottom: 1rem;
            font-size: 0.75rem;
        }
    </style>
</head>
<body>
    <div id="app">
        <!-- Header -->
        <header class="app-header">
            <div class="header-logo">
                <h1>Test Module Interprètes</h1>
            </div>
        </header>

        <!-- Navigation avec scroll latéral -->
        <nav class="tab-navigation">
            <button class="tab-btn" data-tab="agenda">
                <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect>
                    <line x1="16" y1="2" x2="16" y2="6"></line>
                    <line x1="8" y1="2" x2="8" y2="6"></line>
                    <line x1="3" y1="10" x2="21" y2="10"></line>
                </svg>
                <span>Agenda</span>
            </button>
            <button class="tab-btn" data-tab="waitlist">
                <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M9 11H3v2h6v-2zm0-4H3v2h6V7zm0 8H3v2h6v-2zm12-8h-6v2h6V7zm0 4h-6v2h6v-2zm0 4h-6v2h6v-2z"/>
                </svg>
                <span>Liste d'attente</span>
            </button>
            <button class="tab-btn active" data-tab="interpretes">
                <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <circle cx="12" cy="8" r="5"></circle>
                    <path d="M20 21a8 8 0 1 0-16 0"></path>
                    <path d="M12 14c-4 0-7 2-7 5"></path>
                </svg>
                <span>Interprètes</span>
            </button>
            <button class="tab-btn" data-tab="publipostage">
                <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path>
                    <polyline points="14 2 14 8 20 8"></polyline>
                    <line x1="16" y1="13" x2="8" y2="13"></line>
                    <line x1="16" y1="17" x2="8" y2="17"></line>
                </svg>
                <span>Publipostage</span>
            </button>
            <button class="tab-btn" data-tab="prisons">
                <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect>
                    <line x1="9" y1="9" x2="15" y2="9"></line>
                    <line x1="9" y1="15" x2="15" y2="15"></line>
                    <line x1="12" y1="3" x2="12" y2="21"></line>
                </svg>
                <span>Prison</span>
            </button>
            <button class="tab-btn" data-tab="stats">
                <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <line x1="18" y1="20" x2="18" y2="10"></line>
                    <line x1="12" y1="20" x2="12" y2="4"></line>
                    <line x1="6" y1="20" x2="6" y2="14"></line>
                </svg>
                <span>Statistiques</span>
            </button>
        </nav>

        <!-- Content -->
        <main class="tab-content">
            <div id="interpretes" class="tab-pane active">
                <div class="toolbar">
                    <input type="search" id="interpretes-search" placeholder="Rechercher par langue, lieu..." class="search-input">
                    <select id="interpretes-sort" class="filter-select">
                        <option value="langue">Trier par Langue</option>
                        <option value="lieu">Trier par Lieu</option>
                        <option value="date">Trier par Date limite</option>
                    </select>
                </div>
                <div class="interpretes-summary">
                    <div class="summary-card">
                        <span class="summary-label">Interprètes en attente</span>
                        <span id="interpretes-total" class="summary-value">0</span>
                    </div>
                    <div class="summary-card">
                        <span class="summary-label">Langues actives</span>
                        <span id="langues-total" class="summary-value">0</span>
                    </div>
                </div>
                <div id="interpretes-container" class="interpretes-grid"></div>
            </div>
        </main>
    </div>

    <!-- Résultats des tests -->
    <div class="test-results">
        <div class="device-info">
            <strong>Device Info:</strong><br>
            <span id="device-type"></span><br>
            <span id="screen-size"></span><br>
            <span id="user-agent"></span>
        </div>
        <div id="test-output"></div>
    </div>

    <script>
        // Données de test avec interprètes - Interface de contact rapide
        const testDatabase = {
            expertises: [
                {
                    "_uniqueId": "test1",
                    "patronyme": "Ahmed HASSAN",
                    "lieu_examen": "Bobigny",
                    "date_examen": "2025-09-15",
                    "limite_oce": "2025-09-10",
                    "tribunal": "Bobigny",
                    "notes": "14h - int. Arabe",
                    "statut": "programmee"
                },
                {
                    "_uniqueId": "test2",
                    "patronyme": "Maria GONZALEZ",
                    "lieu_examen": "Paris XIV",
                    "date_examen": "2025-09-20",
                    "limite_oce": "2025-08-25",
                    "tribunal": "Paris",
                    "notes": "10h - int. Espagnol",
                    "statut": "attente"
                },
                {
                    "_uniqueId": "test3",
                    "patronyme": "Li WANG",
                    "lieu_examen": "Créteil",
                    "date_examen": "2025-10-01",
                    "limite_oce": "2025-09-25",
                    "tribunal": "Créteil",
                    "notes": "int. Mandarin - 16h",
                    "statut": "programmee"
                },
                {
                    "_uniqueId": "test4",
                    "patronyme": "Fatima DIALLO",
                    "lieu_examen": "Bobigny",
                    "date_examen": "2025-09-18",
                    "limite_oce": "2025-09-12",
                    "tribunal": "Bobigny",
                    "notes": "int. Soninké",
                    "statut": "attente"
                },
                {
                    "_uniqueId": "test5",
                    "patronyme": "Dmitri PETROV",
                    "lieu_examen": "Paris IX",
                    "date_examen": "2025-09-25",
                    "limite_oce": "2025-09-20",
                    "tribunal": "Paris",
                    "notes": "int. Russe - traduction simultanée",
                    "statut": "programmee"
                },
                {
                    "_uniqueId": "test7",
                    "patronyme": "Carmen RODRIGUEZ",
                    "lieu_examen": "Bobigny",
                    "date_examen": "2025-09-22",
                    "limite_oce": "2025-09-15",
                    "tribunal": "Bobigny",
                    "notes": "int. Espagnol - 15h",
                    "statut": "programmee"
                },
                {
                    "_uniqueId": "test8",
                    "patronyme": "Yusuf AL-RASHID",
                    "lieu_examen": "Créteil",
                    "date_examen": "2025-09-28",
                    "limite_oce": "2025-09-18",
                    "tribunal": "Créteil",
                    "notes": "int. Arabe - dialecte marocain",
                    "statut": "attente"
                },
                {
                    "_uniqueId": "test6",
                    "patronyme": "John SMITH",
                    "lieu_examen": "Versailles",
                    "date_examen": "2025-09-30",
                    "limite_oce": "2025-09-22",
                    "tribunal": "Versailles",
                    "notes": "Pas d'interprète nécessaire",
                    "statut": "programmee"
                }
            ]
        };

        // Classe de test simplifiée
        class TestCrimiTrackInterpretes {
            constructor() {
                this.database = testDatabase;
                this.testResults = [];
                this.init();
            }

            init() {
                this.detectDevice();
                this.runTests();
                this.updateInterpretes();
            }

            detectDevice() {
                const userAgent = navigator.userAgent;
                const screenWidth = window.screen.width;
                const screenHeight = window.screen.height;
                
                let deviceType = 'Desktop';
                if (/iPhone/.test(userAgent)) deviceType = 'iPhone';
                else if (/iPad/.test(userAgent)) deviceType = 'iPad';
                else if (/Android/.test(userAgent)) deviceType = 'Android';
                else if (screenWidth <= 768) deviceType = 'Mobile';
                else if (screenWidth <= 1024) deviceType = 'Tablet';

                document.getElementById('device-type').textContent = deviceType;
                document.getElementById('screen-size').textContent = `${screenWidth}x${screenHeight}`;
                document.getElementById('user-agent').textContent = userAgent.substring(0, 50) + '...';
            }

            runTests() {
                // Test 1: Filtrage des interprètes EN ATTENTE uniquement
                const interpretesExpertises = this.database.expertises.filter(exp => {
                    const notes = exp.notes || '';
                    const statut = exp.statut || '';
                    return notes.toLowerCase().includes('int.') && statut.toLowerCase() === 'attente';
                });
                this.addTestResult(interpretesExpertises.length === 3, `Filtrage interprètes en attente: ${interpretesExpertises.length}/3 trouvés`);

                // Test 2: Extraction des langues avec drapeaux
                const languesInfo = interpretesExpertises.map(exp => this.getLangueInfo(exp.notes || ''));
                const languesUniques = new Set(languesInfo.map(l => l.name));
                this.addTestResult(languesUniques.size === 3, `Langues détectées: ${languesUniques.size}/3 (${Array.from(languesUniques).join(', ')})`);

                // Test 3: Groupement par langue → lieu → limite OCE
                let groupedByLangue = {};
                interpretesExpertises.forEach(exp => {
                    const langueInfo = this.getLangueInfo(exp.notes || '');
                    const lieu = exp.lieu_examen || 'Lieu non spécifié';
                    
                    if (!groupedByLangue[langueInfo.name]) {
                        groupedByLangue[langueInfo.name] = { flag: langueInfo.flag, lieux: {} };
                    }
                    if (!groupedByLangue[langueInfo.name].lieux[lieu]) {
                        groupedByLangue[langueInfo.name].lieux[lieu] = [];
                    }
                    groupedByLangue[langueInfo.name].lieux[lieu].push(exp);
                });
                
                const arabeLieux = Object.keys(groupedByLangue['Arabe']?.lieux || {});
                this.addTestResult(arabeLieux.includes('Bobigny') && arabeLieux.includes('Créteil'), `Groupement Arabe: lieux ${arabeLieux.join(', ')}`);

                // Test 4: Navigation responsive
                const navigation = document.querySelector('.tab-navigation');
                const scrollable = navigation.scrollWidth > navigation.clientWidth;
                this.addTestResult(true, `Navigation scroll: ${scrollable ? 'Activé' : 'Pas nécessaire'}`);

                // Test 5: Gestion de l'urgence
                const urgentCases = interpretesExpertises.filter(exp => {
                    const urgence = this.getUrgenceLevel(exp.limite_oce);
                    return urgence === 'urgent' || urgence === 'depassee';
                });
                this.addTestResult(urgentCases.length > 0, `Cas urgents détectés: ${urgentCases.length}`);

                // Test 6: Fonction de contact
                const contactButtonTest = typeof this.contactInterpreter === 'function';
                this.addTestResult(contactButtonTest, `Fonction contact: ${contactButtonTest ? 'Disponible' : 'Manquante'}`);

                this.displayTestResults();
            }

            addTestResult(success, message) {
                this.testResults.push({ success, message });
            }

            displayTestResults() {
                const output = document.getElementById('test-output');
                let html = '';
                let successCount = 0;

                this.testResults.forEach(result => {
                    if (result.success) successCount++;
                    html += `<div class="${result.success ? 'test-success' : 'test-error'}">
                        ${result.success ? '✅' : '❌'} ${result.message}
                    </div>`;
                });

                html = `<div class="test-info">Tests: ${successCount}/${this.testResults.length} réussis</div>` + html;
                output.innerHTML = html;
            }

            // Méthodes de l'application principale (simplifiées)
            extractLangue(notes) {
                const match = notes.match(/int\\.\\s*([a-záàâäéèêëïîôùûüÿçñ\\s\\-]+)/i);
                if (match) {
                    let langue = match[1].trim();
                    // Normaliser les langues connues
                    langue = langue.charAt(0).toUpperCase() + langue.slice(1).toLowerCase();
                    
                    // Gérer les cas spéciaux
                    if (langue.includes('arabe')) return 'Arabe';
                    if (langue.includes('espagnol')) return 'Espagnol';
                    if (langue.includes('soninké')) return 'Soninké';
                    if (langue.includes('mandarin') || langue.includes('chinois')) return 'Mandarin';
                    if (langue.includes('russe')) return 'Russe';
                    
                    return langue;
                }
                return 'Non spécifiée';
            }
            
            getLangueInfo(notes) {
                const langue = this.extractLangue(notes);
                const langueMap = {
                    'Arabe': { flag: '🇸🇦', name: 'Arabe' },
                    'Espagnol': { flag: '🇪🇸', name: 'Espagnol' },
                    'Mandarin': { flag: '🇨🇳', name: 'Mandarin' },
                    'Chinois': { flag: '🇨🇳', name: 'Chinois' },
                    'Russe': { flag: '🇷🇺', name: 'Russe' },
                    'Soninké': { flag: '🇲🇱', name: 'Soninké' },
                    'Non spécifiée': { flag: '🗣️', name: 'Non spécifiée' }
                };
                return langueMap[langue] || { flag: '🗣️', name: langue };
            }
            
            contactInterpreter(expertiseId) {
                const expertise = this.database.expertises.find(exp => exp._uniqueId === expertiseId);
                if (expertise) {
                    const langueInfo = this.getLangueInfo(expertise.notes || '');
                    const message = `Bonjour, êtes-vous disponible pour une expertise en ${langueInfo.name} ?\\n\\nLieu: ${expertise.lieu_examen}\\nDate: ${expertise.date_examen ? new Date(expertise.date_examen).toLocaleDateString('fr-FR') : 'À programmer'}\\nPersonne: ${expertise.patronyme}\\n\\nMerci !`;
                    
                    if (navigator.share) {
                        navigator.share({
                            title: `Demande interprète ${langueInfo.name}`,
                            text: message
                        });
                    } else {
                        alert('Message de contact:\\n\\n' + message);
                    }
                }
            }

            getUrgenceLevel(limite_oce) {
                if (!limite_oce) return 'normal';
                
                const limite = new Date(limite_oce);
                const today = new Date();
                const diffTime = limite - today;
                const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));
                
                if (diffDays < 0) return 'depassee';
                if (diffDays <= 7) return 'urgent';
                if (diffDays <= 30) return 'attention';
                return 'normal';
            }

            getUrgenceText(urgence) {
                switch (urgence) {
                    case 'depassee': return '🔴 Dépassée';
                    case 'urgent': return '🟠 Urgent (< 7j)';
                    case 'attention': return '🟡 Attention (< 30j)';
                    default: return '🟢 Normal';
                }
            }

            compareDateLimite(dateA, dateB) {
                if (!dateA && !dateB) return 0;
                if (!dateA) return 1;
                if (!dateB) return -1;
                
                const a = new Date(dateA);
                const b = new Date(dateB);
                return a - b;
            }

            generateInterpreteCard(expertise) {
                const langue = this.extractLangue(expertise.notes || '');
                const urgence = this.getUrgenceLevel(expertise.limite_oce);
                
                return `
                    <div class="interpretes-card ${urgence}">
                        <div class="interpretes-card-header">
                            <span class="interpretes-langue">${langue}</span>
                            <span class="interpretes-urgence ${urgence}">${this.getUrgenceText(urgence)}</span>
                        </div>
                        <div class="interpretes-card-body">
                            <div class="interpretes-info">
                                <strong>${expertise.patronyme || 'Non renseigné'}</strong>
                                <span class="interpretes-lieu">📍 ${expertise.lieu_examen || 'Non renseigné'}</span>
                                <span class="interpretes-date">📅 ${expertise.date_examen ? new Date(expertise.date_examen).toLocaleDateString('fr-FR') : 'Non programmée'}</span>
                                ${expertise.limite_oce ? `<span class="interpretes-limite">⏰ Limite OCE: ${new Date(expertise.limite_oce).toLocaleDateString('fr-FR')}</span>` : ''}
                            </div>
                            <div class="interpretes-details">
                                <span class="interpretes-tribunal">${expertise.tribunal || 'Non renseigné'}</span>
                                <span class="interpretes-notes">${expertise.notes || ''}</span>
                            </div>
                        </div>
                    </div>
                `;
            }

            updateInterpretes() {
                const container = document.getElementById('interpretes-container');
                if (!container) return;
                
                const searchTerm = document.getElementById('interpretes-search')?.value?.toLowerCase() || '';
                
                // Filtrer les expertises nécessitant un interprète ET en attente uniquement
                let interpretesExpertises = this.database.expertises.filter(exp => {
                    const notes = exp.notes || '';
                    const statut = exp.statut || '';
                    return notes.toLowerCase().includes('int.') && statut.toLowerCase() === 'attente';
                });
                
                // Appliquer la recherche
                if (searchTerm) {
                    interpretesExpertises = interpretesExpertises.filter(exp => {
                        const notes = (exp.notes || '').toLowerCase();
                        const lieu = (exp.lieu_examen || '').toLowerCase();
                        const patronyme = (exp.patronyme || '').toLowerCase();
                        return notes.includes(searchTerm) || lieu.includes(searchTerm) || patronyme.includes(searchTerm);
                    });
                }
                
                // TOUJOURS grouper par langue → lieu → limite OCE pour usage rapide
                let groupedByLangue = {};
                
                interpretesExpertises.forEach(exp => {
                    const langueInfo = this.getLangueInfo(exp.notes || '');
                    const lieu = exp.lieu_examen || 'Lieu non spécifié';
                    
                    if (!groupedByLangue[langueInfo.name]) {
                        groupedByLangue[langueInfo.name] = {
                            flag: langueInfo.flag,
                            name: langueInfo.name,
                            total: 0,
                            lieux: {}
                        };
                    }
                    
                    if (!groupedByLangue[langueInfo.name].lieux[lieu]) {
                        groupedByLangue[langueInfo.name].lieux[lieu] = [];
                    }
                    
                    groupedByLangue[langueInfo.name].lieux[lieu].push(exp);
                    groupedByLangue[langueInfo.name].total++;
                });
                
                // Trier les expertises par lieu par limite OCE
                Object.keys(groupedByLangue).forEach(langue => {
                    Object.keys(groupedByLangue[langue].lieux).forEach(lieu => {
                        groupedByLangue[langue].lieux[lieu].sort((a, b) => 
                            this.compareDateLimite(a.limite_oce, b.limite_oce)
                        );
                    });
                });
                
                // Mettre à jour les statistiques
                const totalInterpretes = interpretesExpertises.length;
                const languesUniques = Object.keys(groupedByLangue).length;
                
                document.getElementById('interpretes-total').textContent = totalInterpretes;
                document.getElementById('langues-total').textContent = languesUniques;
                
                // Générer le HTML optimisé pour contact rapide
                let html = '';
                
                if (Object.keys(groupedByLangue).length > 0) {
                    Object.keys(groupedByLangue).sort().forEach(langue => {
                        const langueData = groupedByLangue[langue];
                        
                        html += `
                            <div class="interpretes-groupe-langue">
                                <div class="interpretes-langue-header-new">
                                    <span class="langue-flag">${langueData.flag}</span>
                                    <span class="langue-name">${langueData.name}</span>
                                    <span class="langue-count">(${langueData.total})</span>
                                </div>
                                <div class="interpretes-lieux-container">
                        `;
                        
                        // Grouper par lieu
                        Object.keys(langueData.lieux).sort().forEach(lieu => {
                            const expertisesLieu = langueData.lieux[lieu];
                            
                            html += `
                                <div class="interpretes-lieu-groupe">
                                    <div class="interpretes-lieu-header">
                                        <span class="lieu-icon">📍</span>
                                        <span class="lieu-name">${lieu}</span>
                                        <span class="lieu-count">(${expertisesLieu.length})</span>
                                    </div>
                                    <div class="interpretes-expertises-list">
                            `;
                            
                            expertisesLieu.forEach(exp => {
                                html += this.generateCompactInterpreteCard(exp);
                            });
                            
                            html += `
                                    </div>
                                </div>
                            `;
                        });
                        
                        html += `
                                </div>
                            </div>
                        `;
                    });
                }
                
                if (html === '') {
                    html = `
                        <div class="empty-state">
                            <div class="empty-icon">🗣️</div>
                            <h3>Aucune expertise nécessitant un interprète</h3>
                            <p>Les expertises avec "int. LANGUE" dans les notes apparaîtront ici</p>
                        </div>
                    `;
                }
                
                container.innerHTML = html;
            }
            
            generateCompactInterpreteCard(expertise) {
                const urgence = this.getUrgenceLevel(expertise.limite_oce);
                const urgenceIcon = this.getUrgenceIcon(urgence);
                
                return `
                    <div class="interpretes-card-compact ${urgence}">
                        <div class="compact-main-info">
                            <div class="compact-person">
                                <strong class="person-name">${expertise.patronyme || 'Non renseigné'}</strong>
                                <span class="compact-urgence ${urgence}">${urgenceIcon}</span>
                            </div>
                            <div class="compact-timing">
                                <span class="compact-date">📅 ${expertise.date_examen ? new Date(expertise.date_examen).toLocaleDateString('fr-FR') : 'Non programmée'}</span>
                                ${expertise.limite_oce ? `<span class="compact-limite">⏰ ${new Date(expertise.limite_oce).toLocaleDateString('fr-FR')}</span>` : ''}
                            </div>
                        </div>
                        <div class="compact-details">
                            <span class="compact-tribunal">${expertise.tribunal || 'Non renseigné'}</span>
                            <span class="compact-notes">${expertise.notes || ''}</span>
                        </div>
                        <div class="compact-actions">
                            <button onclick="testApp.contactInterpreter('${expertise._uniqueId}')" class="btn-contact" title="Contacter l'interprète">📞</button>
                            <button onclick="testApp.editExpertise('${expertise._uniqueId}')" class="btn-edit" title="Modifier">✏️</button>
                        </div>
                    </div>
                `;
            }
            
            getUrgenceIcon(urgence) {
                switch (urgence) {
                    case 'depassee': return '🔴';
                    case 'urgent': return '🟠';
                    case 'attention': return '🟡';
                    default: return '🟢';
                }
            }
            
            editExpertise(id) {
                alert('Fonction modifier pour expertise ID: ' + id);
            }
        }

        // Démarrer les tests
        let testApp;
        document.addEventListener('DOMContentLoaded', () => {
            testApp = new TestCrimiTrackInterpretes();
            
            // Event listeners pour les tests en temps réel
            document.getElementById('interpretes-search')?.addEventListener('input', () => testApp.updateInterpretes());
            document.getElementById('interpretes-sort')?.addEventListener('change', () => testApp.updateInterpretes());
        });
    </script>
</body>
</html>